#!/usr/bin/perl
use threads;
use MIME::Base64;
use File::Basename;
use Getopt::Long qw(:config bundling no_ignore_case no_autoabbrev passthrough);
use POSIX;
use strict;

my ($LOG_FILE_HANDLE);
my $MAIN_PID = substr("000000".$$,-6);
(my $CMD_NAME = $0) =~ s!.*/(.*)!$1!;
my $WORK_PATH = "/tmp";

if($ENV{PATH} !~ "/sbin"){
    $ENV{PATH}=$ENV{PATH}.":/sbin";
}
my @NEED_COMMAND = ("ip","sed","zip","unzip","less","bash","tar","perl","expect","ssh","ifconfig","mkfs.xfs");
my ($SQL_SPLIT,$CMD_SPLIT,$SQL_DELIM,$RECORD_SPLIT) = ('chr(1)||chr(2)||chr(7)',chr(1).chr(2).chr(7),chr(3).chr(4).chr(8),chr(5).chr(6).chr(9).chr(10));

my ($HOSTS_CONFIG,$PASSWORD,$INSTALL_FILE,$GP_VERSION,$MASTER_DEV,@SEGMENT_DEV,$USER_ID,$SEGS_PER_DISK,$PREFIX,$MASTER_PORT,$PORT_BASE,$MIRROR_SPLIT,$IGNORE_INIT,$EXPAND,@GP_CONFIG,$VERBOSE,$PARAMETER_FILE,$IS_HELP);
my (@MASTER_CONFIG,@STANDBY_CONFIG,@ALLHOST_CONFIG_ARRAY,@SEG_INSTALL_CONFIG_ARRAY);
my ($CLUSTER_EXISTS,$INSTALL_VERSION,$CAN_USE_EXPECT,$CURRENT_USER_NAME,$GP_ADMIN_NAME,$GP_ADMIN_PASSWD);
my (%SEGMENT_IP_HASH,%SEGMENT_HOST_HASH,%EXISTS_IP_HASH,%EXISTS_HOST_HASH,$EXISTS_MIRROR,$PRIMARY_COUNT,$MIRROR_COUNT,$MAX_CONTENT,$MAX_DBID);
my %DEFAULT_GPCONFIG = (
        "max_appendonly_tables"                       => "-v 50000 -m 50000",
        "gp_max_partition_level"                      => "-v 1 -m 1",
        "log_min_duration_statement"                  => "-v 30000 -m 30000",
        "gp_workfile_limit_per_query"                 => "-v 134217728 -m 134217728",
        "gp_enable_relsize_collection"                => "-v on -m on",
        "gp_workfile_limit_per_segment"               => "-v 134217728 -m 134217728",
        "gp_max_local_distributed_cache"              => "-v 1048576",
        "gp_workfile_compress_algorithm"              => "-v zlib",
        "gp_autostats_mode_in_functions"              => "-v ON_NO_STATS -m ON_NO_STATS",
        "writable_external_table_bufsize"             => "-v 16MB -m 16MB",
        "gp_create_table_random_default_distribution" => "-v on -m on",
        "max_fsm_pages"                               => "-v 2000000 -m 2000000",
        "max_fsm_relations"                           => "-v 30000 -m 30000",
        "log_timezone"                                => "-v HONGKONG -m HONGKONG",
);
my ($COMMAND_FILE_NAME) = ($WORK_PATH."/install_command.sh");
my ($ssh) = ("ssh -o NumberOfPasswordPrompts=1");

my $HELP_MESSAGE = qq#COMMAND NAME: $CMD_NAME
Auto install and initialize greenplum cluster.

Developed by Miao Chen

Work Email:
michen\@pivotal.io
Private Email:
miaochen\@mail.ustc.edu.cn
************************************************************************************************
SYNOPSIS
************************************************************************************************
$CMD_NAME --hosts-config <filename>
    [--password <current user password>]
    [--gp-admin-name <gp admin user name>]
    [--gp-admin-passwd <gp admin user passwd>]
    --install-file <greenplum binary file>
    --gp-version <greenplum version>
    --mas-dev <device or directory for master>
    --seg-dev <device or directory for segment> [--seg-dev <device or directory for segment> ...]
    [--user-id <gp admin user id>]
    [--segs-per-disk <instance amount on one device or directory>]
    [--prefix <instance directory name prefix>]
    [--mas-port <master work port>]
    [--port-base <primary instance port base>]
    [--mirror-split <amount of machine which mirror split to>]
    [--ignore-init]
    [--expand]
    [--gpconfig <gpconfig parameter and value> [--gpconfig <gpconfig parameter and value>] ...]
    [--verbose | -v]
    [--parameter-file | --pf <parameter file>]
    [-h | --help]
*****************************************************
DESCRIPTION
*****************************************************
The $CMD_NAME utility is used to auto configure, install and initialize a GP system or cluster.

Command will log message to log file on path /tmp/gpdbinstall_YYYYmmdd.log
*****************************************************
OPTIONS
*****************************************************

--hosts-config <filename>

  A file contains machine configure like:
  IP address      hostname    role     position
  192.168.88.10 : mdw001  :  Master  :   0.01
  192.168.88.11 : mdw002  :  Standby :   0.02
  192.168.88.80 : sdw001  :  Segment :   1.01
  192.168.88.81 : sdw002  :  Segment :   1.02
  192.168.88.82 : sdw003  :  Segment :   1.03
  192.168.88.83 : sdw004  :  Segment :   2.11
  192.168.88.84 : sdw005  :  Segment :   2.12
  192.168.88.85 : sdw006  :  Segment :   2.13
  192.168.88.86 : sdw007  :  Segment :   3.001
  192.168.88.87 : sdw008  :  Segment :   3.012
  192.168.88.88 : sdw009  :  Segment :   3.123
  192.168.88.89 : sdw010  :  Backup  :   0.00

  One line have 4 attribute and meaning:
  IP Address      hostname   role        position
  IP Address means, this machine will used in this cluster.
  hostname means, this machine will config hostname as this.
  role means, Master as GP master, Standby as GP standby, Segment as GP segment, Expand as New Added segment, any other as spare machine for GP segment.
  position means, which position this machine owner to, shoud specify float number, the interger part means which mirror loop this host owner to,
      and the decimal part means the order in the mirror loop.

--password <password>

  Current user's password, you should make sure the password are the same between all the machines.
  If not specify this parameter, command will prompt to input this password.

--gp-admin-name <user name>

  Use user name as greenplum database's admin user.
  If install user is root, default user is gpadmin.
  If install user is not root, default user is current user.

--gp-admin-passwd <user passwd>

  Set the gpadmin database's admin user's password.
  If not specify this parameter, use the user name as password.

--install-file <greenplum binary file>

  Greenplum database binary install file, should named like:
  greenplum-db-XX.XX.XX[.XX]-rhel5-x86_64.(zip|bin)

  the XX.XX.XX[.XX] means the version number.

--gp-version <greenplum version>

  Greenplum database version, will search exists installed version on path /usr/local.
  If specify this parameter, utility will ignore the parameter --gp-version.
  e.g.:
  --gp-version 5.10.2
  or
  --gp-version 4.3.29.0

--mas-dev <path or device>

  Use this device or directory for master work directory.
  If this is a path, will use it directly,
      else if this is a device, command will try to config it, make it as xfs filesystem,
      but others, command will exit with an error.
  e.g.:
  --mas-dev /dev/sdc
  or:
  --mas-dev /data

--seg-dev <path or device> [--seg-dev <path or device> ...]

  Use this device or directory for segment work directory.
  If this is a path, will use it directly,
      else if this is a device, command will try to config it, make it as xfs filesystem,
      but others, command will exit with an error.
  e.g.:
  --seg-dev /dev/sdc --seg-dev /dev/sde
  or:
  --seg-dev /data1 --seg-dev /data2

[--user-id <userid for OS>]

  Use this id for OS user (for gp admin user), if not specify, use 500 for default.

[--segs-per-disk <number>]

  Initlize how many primary instance on one device or path, default is 2

[--prefix <prefix>]

  Instance directory name prefix, defualt is gpseg

[--mas-port <Master work port>]

  Master work port, default is 5432

[--port-base <port base>]

  Primary instance work port base, primary replication port is 1000 bigger than this,
  Mirror instance work port is 10000 bigger than this, and which replication port is 11000 bigger than this.
  Default is 40000

[--mirror-split <number>]

  How many machine used to split one machine's mirror instance.
  If this number + 1 bigger or equal to one mirror loop's machine amount, command will exit with error.
  If specify this parameter as 0, command will not config mirror for this cluster.
  Default is 2

[--ignore-init]

  Ignore all greenplum initialization operation.
  Just do all prepare operation for greenplum as:
  OS parameter modify.
  SSH keys exchange.
  And so on.

[--expand]

  Config OS parameter and create expand input file for gpexpand.
  After execute this command success, will generate two files for gpexpand,
  then you can execute gpexpand -i use the two files.

[--gpconfig <parameter and value> [--gpconfig <parameter and value>] ...]

  After success init cluster, to run gpcinfig to config greenplum parameters.
  e.g.:
  --gpconfig "gp_workfile_compress_algorithm = -v zlib"

[--verbose | -v]

  Command will output verbose message.

[--parameter-file | -- pf <file>]

  Specify the parameter in file.
  Format:
  name=value
  Like:
  hosts-config    = hosts-config
  gp-admin-name   = gpadmin
  gp-admin-passwd = gpadminpasswd
  install-file    = greenplum-db-5.9.0-rhel7-x86_64.zip
  mas-dev         = /data
  seg-dev         = /data1
  seg-dev         = /data2
  user-id         = 500
  segs-per-disk   = 2
  prefix          = gpseg
  mas-port        = 5432
  port-base       = 40000
  mirror-split    = 2
  gpconfig        = gp_workfile_compress_algorithm = -v zlib
  verbose

[-h|--help]

  Displays the online help.

Examples:

gpdbinstall --hosts-config hosts-config --install-file greenplum-db-5.9.0-rhel7-x86_64.zip --mas-dev /data --seg-dev /data --gp-admin-name gpuser --user-id 3030 --mirror-split 1 -v
#;

sub trim{
    my ($string) = @_;
    $string =~ s/(^\s+|\s+$)//g;
    return $string;
}
sub encode{
    my ($string) = @_;
    my $encode = encode_base64($string);
    $encode =~ s/\n//g;
    return $encode;
}
sub decode{
    if(wantarray()){
        my @rv = ();
        for my $str(@_){
            push @rv,decode_base64($str);
        }
        return @rv;
    }else{
        return decode_base64($_[0]);
    }
}
sub printMessage{
    my ($flag,$message) = @_;
    my $time_flag = strftime("%Y%m%d:%H:%M:%S.",localtime).$MAIN_PID;
    $message = "$time_flag-[$flag]-:$message\n";
    if($flag eq "ERROR"){
        print STDERR $message;
    }else{
        print STDOUT $message;
    }
    return $message;
}
sub logMessage{
    my ($flag,$message) = @_;
    my $log_message = printMessage($flag,$message);
    if($LOG_FILE_HANDLE eq ""){
        my $log_file_date = strftime("%Y%m%d",localtime);
        open($LOG_FILE_HANDLE,">>","/tmp/gpdbinstall_$log_file_date.log");
    }
    print $LOG_FILE_HANDLE $log_message;
}
sub errorMessage{
    my ($message) = @_;
    logMessage("ERROR",$message);
    print "Usage: $CMD_NAME [-h|--help] [options]\n";
    exit 1;
}
sub readLineFromFile{
    my ($file_path) = @_;
    if(!-e $file_path){
        errorMessage("No file exists named: $file_path");
    }
    if(!open(FILE,"<",$file_path)){
        errorMessage("Can't open file: $file_path");
    }
    my @line_list = ();
    while(my $line = <FILE>){
        $line = trim($line);
        if(!($line =~ /^#/) && $line ne ""){
            push @line_list,$line;
        }
    }
    close FILE;
    return @line_list;
}
sub executeWithExpect{
    my ($command,$expect_eof) = @_;
    my $expect = "expect 2>&1 <<'END_OF_EXPECT'"."\n";
    $expect = $expect.'spawn '.$command."\n";
    $expect = $expect.'set timeout 180'."\n";
    my $para_size = @_;
    for my $index(2 .. $para_size - 1){
        my $match_send_list = $_[$index];
        $expect = $expect.'expect {'."\n";
        for my $match_send(@$match_send_list){
            my ($match,$send,$continue) = @$match_send;
            $expect = $expect.'    "'.$match.'" { send "'.$send.'\r"'.($continue ? '; exp_continue ' : '').' }'."\n";
        }
        $expect = $expect.'}'."\n";
    }
    if($expect_eof){
        $expect = $expect.'expect eof {  }'."\n";
    }
    $expect = $expect.'catch wait exitcode'."\n";
    $expect = $expect.'exit [lindex $exitcode 3]'."\n";
    $expect = $expect.'END_OF_EXPECT'."\n";
    if($VERBOSE){
        logMessage("INFO","Expect command:\n".$expect);
    }
    my $output = readpipe($expect);
    my $exit_code = $? >> 8;
    if($exit_code != 0 && $output !~ /expect: spawn id .* not open/){
        errorMessage("Error($exit_code) occur when execute expect:\n".$output);
    }
    if($VERBOSE){
        logMessage("INFO","Expect output:\n".$output);
    }
    return $output;
}
sub getOption{
    GetOptions(
        'hosts-config:s'      => \$HOSTS_CONFIG,
        'password:s'          => \$PASSWORD,
        'gp-admin-name:s'     => \$GP_ADMIN_NAME,
        'gp-admin-passwd:s'   => \$GP_ADMIN_PASSWD,
        'install-file:s'      => \$INSTALL_FILE,
        'gp-version:s'        => \$GP_VERSION,
        'mas-dev:s'           => \$MASTER_DEV,
        'seg-dev:s'           => \@SEGMENT_DEV,
        'user-id:i'           => \$USER_ID,
        'segs-per-disk:i'     => \$SEGS_PER_DISK,
        'prefix:s'            => \$PREFIX,
        'mas-port:i'          => \$MASTER_PORT,
        'port-base:i'         => \$PORT_BASE,
        'mirror-split:i'      => \$MIRROR_SPLIT,
        'ignore-init!'        => \$IGNORE_INIT,
        'expand!'             => \$EXPAND,
        'gpconfig:s'          => \@GP_CONFIG,
        'verbose|v!'          => \$VERBOSE,
        'parameter-file|pf:s' => \$PARAMETER_FILE,
        'h|help!'             => \$IS_HELP,
    );
    if(@ARGV != 0){
        errorMessage("Some parameters unknown: [@ARGV]\nPlease refer to $CMD_NAME --help");
    }
    if($IS_HELP){
        print $HELP_MESSAGE;
        exit 0;
    }
    if($PARAMETER_FILE ne ""){
        my @parameter_list = readLineFromFile($PARAMETER_FILE);
        for my $line(@parameter_list){
            my ($para,$val) = split(/=/,$line,2);
            ($para,$val) = (trim($para),trim($val));
            if("hosts-config"    eq $para  && "" eq $HOSTS_CONFIG    ){$HOSTS_CONFIG     = $val;}
            if("password"        eq $para  && "" eq $PASSWORD        ){$PASSWORD         = $val;}
            if("gp-admin-name"   eq $para  && "" eq $GP_ADMIN_NAME   ){$GP_ADMIN_NAME    = $val;}
            if("gp-admin-passwd" eq $para  && "" eq $GP_ADMIN_PASSWD ){$GP_ADMIN_PASSWD  = $val;}
            if("install-file"    eq $para  && "" eq $INSTALL_FILE    ){$INSTALL_FILE     = $val;}
            if("gp-version"      eq $para  && "" eq $GP_VERSION      ){$GP_VERSION       = $val;}
            if("mas-dev"         eq $para  && "" eq $MASTER_DEV      ){$MASTER_DEV       = $val;}
            if("seg-dev"         eq $para                            ){push @SEGMENT_DEV , $val;}
            if("user-id"         eq $para  && "" eq $USER_ID         ){$USER_ID          = $val;}
            if("segs-per-disk"   eq $para  && "" eq $SEGS_PER_DISK   ){$SEGS_PER_DISK    = $val;}
            if("prefix"          eq $para  && "" eq $PREFIX          ){$PREFIX           = $val;}
            if("mas-port"        eq $para  && "" eq $MASTER_PORT     ){$MASTER_PORT      = $val;}
            if("port-base"       eq $para  && "" eq $PORT_BASE       ){$PORT_BASE        = $val;}
            if("mirror-split"    eq $para  && "" eq $MIRROR_SPLIT    ){$MIRROR_SPLIT     = $val;}
            if("ignore-init"     eq $para  && "" eq $IGNORE_INIT     ){$IGNORE_INIT      = 1   ;}
            if("expand"          eq $para  && "" eq $EXPAND          ){$EXPAND           = 1   ;}
            if("gpconfig"        eq $para                            ){push @GP_CONFIG   , $val;}
            if(("verbose"        eq $para  ||
                "v"              eq $para) && "" eq $VERBOSE         ){$VERBOSE          = 1   ;}
        }
    }
}
sub checkEnvironment{
    $CURRENT_USER_NAME = trim(readpipe("whoami"));
    if($GP_ADMIN_NAME eq ""){
        if($CURRENT_USER_NAME eq "root"){
            $GP_ADMIN_NAME = "gpadmin";
        }else{
            $GP_ADMIN_NAME = $CURRENT_USER_NAME;
        }
        logMessage("WARN","Not specify parameter: --gp-admin-user, will use default user:\n".$GP_ADMIN_NAME);
    }
    if($GP_ADMIN_PASSWD eq ""){
        $GP_ADMIN_PASSWD = $GP_ADMIN_NAME;
    }
    readpipe(qq{timeout -s 9 1 sudo date});
    my $sudoCode = $?;
    if($sudoCode != 0){
        errorMessage("Current user $CURRENT_USER_NAME can not sudo to root without password");
    }
    my $whichCode;
    my @problemList = ();
    for my $cmd(@NEED_COMMAND){
        system("which $cmd > /dev/null 2>&1");
        $whichCode = $? >> 8;
        if($whichCode != 0){
            push @problemList,$cmd;
        }
    }
    if(@problemList > 0){
        errorMessage("Environment not enough to continue install, command ".join(',',@problemList)." not found in current environment");
    }else{
        logMessage("INFO","All command ".(join(',',@NEED_COMMAND))." found in current environment");
    }
}
sub checkOption{
    logMessage("INFO","Check options legal".("." x 16));
    if(!-f $HOSTS_CONFIG){
        errorMessage("Please specify parameter: --hosts-config");
    }
    if($INSTALL_FILE eq "" && $GP_VERSION eq ""){
        errorMessage("Please specify parameter: --install-file or --gp-version");
    }
    if($GP_VERSION ne ""){
        my $install_path = "/usr/local/greenplum-db-$GP_VERSION";
        if(!-e $install_path){
            errorMessage("Install path not exists: $install_path");
        }
        $INSTALL_VERSION = $GP_VERSION;
    }elsif( !-f $INSTALL_FILE){
        errorMessage("File not exists: $INSTALL_FILE");
    }
    if($MASTER_DEV eq ""){
        errorMessage("Please specify parameter: --mas-dev");
    }
    if(@SEGMENT_DEV < 1){
        errorMessage("Please specify parameter: --seg-dev");
    }else{
        @SEGMENT_DEV = sort {$a cmp $b} @SEGMENT_DEV;
    }
    if($USER_ID eq ""){
        $USER_ID = 500;
        logMessage("NOTICE","Not specify --user-id, use default value: $USER_ID");
    }elsif(int($USER_ID) ne $USER_ID){
        errorMessage("Please specify parameter a integer value: --user-id");
    }
    if($SEGS_PER_DISK eq ""){
        $SEGS_PER_DISK = 2;
        logMessage("NOTICE","Not specify --segs-per-disk, use default value: $SEGS_PER_DISK");
    }elsif(int($SEGS_PER_DISK) ne $SEGS_PER_DISK){
        errorMessage("Please specify parameter a integer value: --segs-per-disk");
    }elsif($SEGS_PER_DISK < 1){
        errorMessage("Please specify parameter bigger than 0: --segs-per-disk");
    }
    if($PREFIX eq ""){
        $PREFIX = "gpseg";
        logMessage("NOTICE","Not specify --prefix, use default value: $PREFIX");
    }
    if($MASTER_PORT eq ""){
        $MASTER_PORT = 5432;
        logMessage("NOTICE","Not specify --mas-port, use default value: $MASTER_PORT");
    }elsif(int($MASTER_PORT) ne $MASTER_PORT){
        errorMessage("Please specify parameter a integer value: --mas-port");
    }elsif($MASTER_PORT > 65535){
        errorMessage("Please specify parameter less than 65535: --mas-port");
    }
    if($PORT_BASE eq ""){
        $PORT_BASE = 40000;
        logMessage("NOTICE","Not specify --port-base, use default value: $PORT_BASE");
    }elsif(int($PORT_BASE) ne $PORT_BASE){
        errorMessage("Please specify parameter a integer value: --port-base");
    }elsif($PORT_BASE > 54000){
        errorMessage("Please specify parameter value less than 54000: --port-base");
    }
    if($MIRROR_SPLIT eq ""){
        $MIRROR_SPLIT = 2;
        logMessage("NOTICE","Not specify --mirror-split, use default value: $MIRROR_SPLIT");
    }
    if($EXPAND ne ""){
        $IGNORE_INIT = 1;
    }
    if($PASSWORD eq ""){
        logMessage("WARN","Please input password for current user:");
        $PASSWORD = <STDIN>;
        $PASSWORD = trim($PASSWORD);
    }
    if($CURRENT_USER_NAME eq $GP_ADMIN_NAME){
        $GP_ADMIN_PASSWD = $PASSWORD;
    }
    $GP_ADMIN_PASSWD = encode($GP_ADMIN_PASSWD);
}
sub queryResult{
    my ($query_sql,$return_flag) = @_;
    my $CMDS = ". /usr/local/greenplum-db/greenplum_path.sh > /dev/null 2>&1;PGDATABASE=postgres PGPORT=$MASTER_PORT ";
    local $/ = $RECORD_SPLIT;
    $CMDS = $CMDS."PGOPTIONS='-c optimizer=off -c client_encoding=UTF8' psql -R '$/' -h 127.0.0.1 -U $GP_ADMIN_NAME -qtAXF '$SQL_DELIM' -v ON_ERROR_STOP=1 2>&1 <<'END_OF_SQL'\n";
    $CMDS = $CMDS.$query_sql."\n";
    $CMDS = $CMDS."END_OF_SQL\n";
    my @result = readpipe($CMDS);
    my $return_code = $? >> 8;
    chomp(@result);
    local $/ = chr(10);
    chomp($result[-1]) if (@result > 0);
    return ($return_code,join("\n",@result)) if ("CV" eq $return_flag);
    errorMessage(join("\n",@result)) if ($return_code);
    return join("\n",@result) if ("Scalar" eq $return_flag);
    my @return_list = ();
    for my $row(@result){
        push @return_list,[split(/$SQL_DELIM/,$row)];
    }
    return @return_list;
}
sub getExistsInformation{
    if(!$EXPAND){
        return;
    }
    my @etc_hosts = readLineFromFile("/etc/hosts");
    my %etc_host_hash = ();
    for my $line(@etc_hosts){
        my($etc_ip,$etc_host) = split(/\s+/,lc($line));
        $etc_host_hash{$etc_host} = $etc_ip;
    }
    my $query = qq{SELECT (SELECT DISTINCT lower(hostname) FROM gp_segment_configuration WHERE content = -1 AND preferred_role = 'p'),
        (SELECT DISTINCT lower(hostname) FROM gp_segment_configuration WHERE content = -1 AND preferred_role = 'm');};
    my @result = queryResult($query);
    my ($master_host,$standby_host) = @{$result[0]};
    if(!exists $etc_host_hash{$master_host}){
        errorMessage("Hostname $master_host not exists in /etc/hosts");
    }
    @MASTER_CONFIG = ($master_host,$etc_host_hash{$master_host});
    if($standby_host ne ""){
        if(!exists $etc_host_hash{$standby_host}){
            errorMessage("Hostname $standby_host not exists in /etc/hosts");
        }
        @STANDBY_CONFIG = ($standby_host,$etc_host_hash{$standby_host});
    }
    $query = qq{SELECT DISTINCT lower(hostname) FROM gp_segment_configuration;};
    @result = queryResult($query);
    for my $row(@result){
        my ($hostname) = @$row;
        if(!exists $etc_host_hash{$hostname}){
            errorMessage("Hostname $hostname not exists in /etc/hosts");
        }
        my $ip = $etc_host_hash{$hostname};
        if(exists $EXISTS_IP_HASH{$ip} || exists $EXISTS_HOST_HASH{$hostname}){
            errorMessage("IP and hostname config in /etc/hosts not uniqe");
        }
        $EXISTS_IP_HASH{$ip} = $hostname;
        if($hostname eq $master_host){
            $EXISTS_HOST_HASH{$hostname} = "MASTER";
        }elsif($hostname eq $standby_host){
            $EXISTS_HOST_HASH{$hostname} = "STANDBY";
        }else{
            $EXISTS_HOST_HASH{$hostname} = "S";
        }
    }
    $query = qq{SELECT
    count(*) FILTER(WHERE preferred_role = 'p' AND content >= 0),
    count(*) FILTER(WHERE preferred_role = 'm' AND content >= 0),
    max(content),
    max(dbid)
FROM gp_segment_configuration;};
    @result = queryResult($query);
    ($PRIMARY_COUNT,$MIRROR_COUNT,$MAX_CONTENT,$MAX_DBID)  = @{$result[0]};
    $EXISTS_MIRROR = $PRIMARY_COUNT == $MIRROR_COUNT ? 1 : 0;
    if($EXISTS_MIRROR && $MIRROR_SPLIT < 1){
        errorMessage("Current exists cluster have mirror, expand must specify --mirror-split");
    }
}
sub checkHostsConfig{
    logMessage("INFO","Check host config".("." x 16));
    my @config_list = readLineFromFile($HOSTS_CONFIG);
    for my $config(@config_list){
        my ($ip,$hostname,$role,$ring) = split(/:/,$config);
        ($ip,$hostname,$role,$ring) = (trim(uc($ip)),trim(lc($hostname)),trim(uc($role)),trim(uc($ring)));
        if(exists $EXISTS_IP_HASH{$ip} || exists $EXISTS_HOST_HASH{$hostname}){
            logMessage("WARN","Host $ip $hostname already exists in current cluster, ignore it for expand");
            next;
        }
        if($ring !~ /^\d+\.\d+$/){
            errorMessage("Ring number format must like integer.integer");
        }
        my ($cur_ring,$cur_order) = split(/\./,$ring);
        system(qq{ping $ip -c 1 -w 1 > /dev/null 2>&1});
        my $exit_code = $? >> 8;
        if($exit_code != 0){
            errorMessage("Try to ping ip failed within 1 second: $ip");
        }
        if($role =~ /^M/){
            if(@MASTER_CONFIG > 0){
                logMessage("WARN","Host config incorrect, master config duplicate, continue config it for future use");
            }else{
                @MASTER_CONFIG = ($ip,$hostname);
            }
        }elsif($role =~ /^ST/){
            if(@STANDBY_CONFIG > 0){
                logMessage("WARN","Host config incorrect, standby config duplicate, continue config it for future use");
            }else{
                @STANDBY_CONFIG = ($ip,$hostname);
            }
        }else{
            if(exists $SEGMENT_IP_HASH{$ip}){
                errorMessage("Host config incorrect, ip: $ip duplicate");
            }elsif(exists $SEGMENT_HOST_HASH{$hostname}){
                errorMessage("Host config incorrect, hostname: $hostname duplicate");
            }
            if($role =~ /^SE/){
                push @SEG_INSTALL_CONFIG_ARRAY,[($ip,$hostname,$role,$cur_ring,$cur_order,$ring)];
            }
            $SEGMENT_IP_HASH{$ip} = $hostname;
            $SEGMENT_HOST_HASH{$hostname} = "";
        }
        push @ALLHOST_CONFIG_ARRAY,[($ip,$hostname,$role,$cur_ring,$cur_order)];
    }
    if(!$IGNORE_INIT && @MASTER_CONFIG < 1){
        errorMessage("Not find master machine config");
    }
    if(@SEG_INSTALL_CONFIG_ARRAY < 1){
        errorMessage("Not find segment machine config");
    }
    my ($m_ip,$m_hostname) = @MASTER_CONFIG;
    if(exists $SEGMENT_IP_HASH{$m_ip}){
        logMessage("WARN","Master ip is same with a segment");
        $m_hostname = $SEGMENT_IP_HASH{$m_ip};
        @MASTER_CONFIG = ($m_ip,$m_hostname);
    }
    if(!$IGNORE_INIT){
        my $current_is_master = readpipe(qq{sudo ip a|grep -o ' $m_ip/'});
        if(trim($current_is_master) ne $m_ip.'/'){
            errorMessage("Not find master's ip on current machine: $m_ip.");
        }
    }
    my ($s_ip,$s_hostname) = @STANDBY_CONFIG;
    if($s_ip eq $m_ip){
        logMessage("WARN","Standby can not on the same machine with Master");
        @STANDBY_CONFIG = ();
    }elsif(exists $SEGMENT_IP_HASH{$s_ip}){
        logMessage("WARN","Standby ip is same with a segment");
        $s_hostname = $SEGMENT_IP_HASH{$s_ip};
        @STANDBY_CONFIG = ($s_ip,$s_hostname);
    }
    my @temp_array = ();
    for my $exists_ip(keys %EXISTS_IP_HASH){
        my $exists_host = $EXISTS_IP_HASH{$exists_ip};
        my $exists_role = $EXISTS_HOST_HASH{$exists_host};
        push @temp_array,[($exists_ip,$exists_host,$exists_role)];
    }
    for my $config(@ALLHOST_CONFIG_ARRAY){
        my ($ip,$hostname,$role,$cur_ring,$cur_order) = @$config;
        if($role =~ /^M/){
            $hostname = $m_hostname;
        }elsif($role =~ /^ST/){
            if(@STANDBY_CONFIG == 0){
                next;
            }
            $hostname = $s_hostname;
        }
        push @temp_array,[($ip,$hostname,$role,$cur_ring,$cur_order)];
    }
    @ALLHOST_CONFIG_ARRAY = @temp_array;
}
sub checkPasswordAndSudo{
    logMessage("INFO","Check password for all machine".("." x 16));
    for my $config(@ALLHOST_CONFIG_ARRAY){
        my ($ip,$hostname,$role,$cur_ring,$cur_order) = @$config;
        my $command = qq{$ssh $ip -T "sudo date"};
        executeWithExpect($command,1,([["yes/no","yes",1],["password",$PASSWORD],["*#"]]));
    }
}
sub checkRingConfig{
    if($IGNORE_INIT){
        logMessage("INFO","Ignore check ring legal");
        return;
    }
    logMessage("INFO","Check ring legal".("." x 16));
    @SEG_INSTALL_CONFIG_ARRAY = sort {$a->[5] <=> $b->[5]} @SEG_INSTALL_CONFIG_ARRAY;
    my $ring_size = 0;
    my $index = 0;
    my $max_index = @SEG_INSTALL_CONFIG_ARRAY - 1;
    my ($pre_ring,$pre_order);
    for my $config(@SEG_INSTALL_CONFIG_ARRAY){
        my ($ip,$hostname,$role,$cur_ring,$cur_order) = @$config;
        if($pre_ring == $cur_ring && $pre_order == $cur_order){
            errorMessage("Diffrent host have same order in same ring");
        }
        if($index == $max_index){
            $ring_size += 1;
        }
        if($ring_size > 0){
            if($pre_ring != $cur_ring || $index == $max_index){
                if($ring_size <= $MIRROR_SPLIT){
                    errorMessage("Host number: $ring_size in one ringe is not enough for mirror split: $MIRROR_SPLIT");
                }
                $ring_size = 0;
            }
        }
        ($pre_ring,$pre_order) = ($cur_ring,$cur_order);
        $ring_size += 1;
    }
}
sub modifySystemConfig{
    logMessage("INFO","Modify system config for greenplum install".("." x 16));
    my $file_handle;
    if(!open($file_handle,">",$COMMAND_FILE_NAME)){
        errorMessage("Can not open file $COMMAND_FILE_NAME");
    }
    my $config_command = readpipe(qq{cat $CMD_NAME|sed -n '/^____CONFIG_COMMAND_SHELL_START____\$/,/^____CONFIG_COMMAND_SHELL_END____\$/p'|grep -v '____'});
    $config_command =~ s/GPSEG/$PREFIX/g;
    print $file_handle $config_command;
    print $file_handle "echo -n '127.0.0.1 = localhost\n";
    print $file_handle "#Greenplum = hosts start\n";
    my ($m_ip,$m_hostname) = @MASTER_CONFIG;
    my ($s_ip,$s_hostname) = @STANDBY_CONFIG;
    for my $config(@ALLHOST_CONFIG_ARRAY){
        my ($ip,$hostname,$role,$cur_ring,$cur_order) = @$config;
        if((($role =~ /^M/ && $ip eq $m_ip) || ($role =~ /^ST/ && $ip eq $s_ip)) && exists $SEGMENT_IP_HASH{$ip}){
            next;
        }
        print $file_handle "$ip = $hostname\n";
    }
    print $file_handle q#'|awk -F ' = ' '{system("sed -e /^"$1"[[:space:]]/d -e '\''/[[:space:]]"$2"[[:space:]]/d'\'' -e '\''/[[:space:]]"$2"$/d'\'' -i /etc/hosts;echo '\''"$1"    "$2"'\'' >> /etc/hosts")}'#."\n";
    print $file_handle "##################################################################################\n";
    close $file_handle;
    my ($master_path,$segment_path);
    for my $config(@ALLHOST_CONFIG_ARRAY){
        my ($ip,$hostname,$role,$cur_ring,$cur_order) = @$config;
        my $mode = "S";
        my $device = join(".",@SEGMENT_DEV);
        if($role =~ "^M" || $role =~ "^ST"){
            $mode = "M";
            $device = $MASTER_DEV;
        }
        my $command = qq{scp -q $COMMAND_FILE_NAME $ip:$COMMAND_FILE_NAME};
        executeWithExpect($command,1,([["yes/no","yes",1],["password",$PASSWORD],["*#"]]));
        $command = qq{$ssh $ip -T "sudo sh $COMMAND_FILE_NAME '$hostname' '$GP_ADMIN_NAME' '$GP_ADMIN_PASSWD' '$USER_ID' '$mode' '$MASTER_PORT' '$device'"};
        my $output = executeWithExpect($command,1,([["yes/no","yes",1],["password",$PASSWORD],["*#"]]));
        my @array = split(/\n/,trim($output));
        my $path;
        for my $line(@array){
            if($line =~ /^####----/){
                $path = trim(substr($line,8));
                last;
            }
        }
        logMessage("INFO","Machine $ip $hostname find data path: $path");
        if($role =~ "^M" || $role =~ "^ST"){
            if($master_path eq ""){
                $master_path = $path;
            }elsif($master_path ne $path){
                errorMessage("Master data path must be same with Standby: $master_path <=> $path");
            }
        }else{
            if($segment_path eq ""){
                $segment_path = $path;
            }elsif($segment_path ne $path){
                errorMessage("Segment data path must be same with all others: $segment_path <=> $path");
            }
        }
        executeWithExpect(qq{$ssh $GP_ADMIN_NAME\@$ip -T "date"},1,([["yes/no","yes",1],["password",decode($GP_ADMIN_PASSWD)],["*#"]]));
    }
    if(!$IGNORE_INIT && $master_path eq ""){
        errorMessage("Not find Master data path");
    }
    if($segment_path eq ""){
        errorMessage("Not find Segment data path");
    }
    $MASTER_DEV = $master_path;
    if($VERBOSE){
        logMessage("INFO","Master install directory is:\n".$master_path);
    }
    @SEGMENT_DEV = split(/ /,$segment_path);
    if($VERBOSE){
        logMessage("INFO","Segment install directory is:\n".$segment_path);
    }
}
sub installThread{
    my ($ip,$hostname) = @_;
    my $encode_cmd = encode(qq#if [ -e /usr/local/greenplum-db-$INSTALL_VERSION ];then
cd /usr/local/
LN=`sudo ls -l /usr/local/|grep '\\sgreenplum-db\\s'|awk '{print \$NF}'`
if [ "\$LN" == "greenplum-db-$INSTALL_VERSION" ];then
    echo EXISTS
    exit 0
fi#.qq#
sudo rm -f greenplum-db > /dev/null 2>&1
sudo ln -s greenplum-db-$INSTALL_VERSION greenplum-db
sudo chown -R $GP_ADMIN_NAME. ./greenplum* > /dev/null 2>&1
echo EXISTS
fi#);
    my $command = qq{$ssh $hostname -T "echo $encode_cmd|base64 -di|bash"};
    my $output = executeWithExpect($command,1,([["yes/no","yes",1],["password",$PASSWORD],["*#"]]));
    if($output =~ /EXISTS/){
        return "SUCCESS";
    }
    $command = qq{scp -q /tmp/greenplum-db.install.tmp.tar $hostname:/tmp/greenplum-db.install.tar};
    executeWithExpect($command,0,([["yes/no","yes",1],["password",$PASSWORD],["*#"]]));
    $command = qq{$ssh $hostname -T "cd /usr/local/;sudo rm -fr greenplum-db-$INSTALL_VERSION;sudo rm -f greenplum-db;sudo tar -xf /tmp/greenplum-db.install.tar;};
    $command = $command.qq{sudo ln -s greenplum-db-$INSTALL_VERSION greenplum-db;sudo chown -R $GP_ADMIN_NAME. greenplum*;sudo rm -f /tmp/greenplum-db.install.tar"};
    executeWithExpect($command,1,([["yes/no","yes"],["password",$PASSWORD],["*#"]]));
}
sub installBinary{
    logMessage("INFO","Try to install binary file on current machine".("." x 16));
    my ($binary_version,$env_file);
    if($EXPAND){
        my $link_name = trim(readpipe(q#sudo ls -l /usr/local/|grep '\sgreenplum-db\s'|awk '{print $NF}'#));
        if($link_name =~ /(\d+(\.\d+){2,3})/){
            $binary_version = $1;
            $INSTALL_VERSION = $binary_version;
        }
    }elsif($GP_VERSION eq ""){
        if($INSTALL_FILE =~ /(\d+(\.\d+){2,3})/){
            $binary_version = $1;
            $env_file = "/usr/local/greenplum-db-$binary_version/greenplum_path.sh";
            if(-f $env_file){
                $INSTALL_VERSION = $binary_version;
            }
        }
        if($INSTALL_VERSION eq ""){
            if($INSTALL_FILE =~ /\.zip$/){
                my $output = trim(readpipe(qq(sudo unzip -o $INSTALL_FILE -d $WORK_PATH/|grep inflating|sed 's/\\s//g'|grep '.bin\$'|awk -F ':' '{print \$2}')));
                if(-f $output && $output =~ /\.bin$/){
                    $INSTALL_FILE = $output;
                }else{
                    errorMessage("Unzip install file $INSTALL_FILE to $WORK_PATH occur error:\n".$output);
                }
            }
            if($INSTALL_FILE !~ /\.bin$/){
                errorMessage("Unidentified file format:\n".$INSTALL_FILE);
            }
            system(qq{if [ -f /etc/cgsl-release ];then sudo touch /etc/redhat-release;fi});
            my $command = qq{sudo bash $INSTALL_FILE};
            executeWithExpect($command,0,([["license agreement","q"]]),([["yes|no","yes"]]),([["installation path",""]]),([["yes|no","yes",1],["*#"]]));
            logMessage("INFO","Try to get install path");
            if($INSTALL_FILE =~ /(\d+(\.\d+){2,3})/){
                $binary_version = $1;
                $env_file = "/usr/local/greenplum-db-$binary_version/greenplum_path.sh";
                if(-f $env_file){
                    $INSTALL_VERSION = $binary_version;
                }
            }
        }
    }else{
        $env_file = "/usr/local/greenplum-db-$GP_VERSION/greenplum_path.sh";
        if(-f $env_file){
            $INSTALL_VERSION = $GP_VERSION;
        }
    }
    if($INSTALL_VERSION eq ""){
        errorMessage("Install greenplum software failed ...");
    }
    system(qq{sudo sed 's/^\\s*MASTER_IPV6_LOCAL_ADDRESS_ALL.*/                MASTER_IPV6_LOCAL_ADDRESS_ALL=(::1)/' -i /usr/local/greenplum-db-$INSTALL_VERSION/bin/gpinitsystem});
    system(qq{sudo sed 's/^\\s*SEGMENT_IPV6_LOCAL_ADDRESS_ALL.*/        SEGMENT_IPV6_LOCAL_ADDRESS_ALL=(::1)/' -i /usr/local/greenplum-db-$INSTALL_VERSION/bin/lib/gpcreateseg.sh});
    logMessage("INFO","Install path is:\n"."/usr/local/greenplum-db-$INSTALL_VERSION");
    my $output = readpipe(qq{cd /usr/local/;sudo tar -cf /tmp/greenplum-db.install.tmp.tar greenplum-db-$INSTALL_VERSION;sudo chown $CURRENT_USER_NAME. /tmp/greenplum-db.install.tmp.tar});
    my @thread_array = ();
    my ($m_ip,$m_hostname) = @MASTER_CONFIG;
    my ($s_ip,$s_hostname) = @STANDBY_CONFIG;
    for my $config(@ALLHOST_CONFIG_ARRAY){
        my ($ip,$hostname,$role,$cur_ring,$cur_order) = @$config;
        if((($role =~ /^M/ && $ip eq $m_ip) || ($role =~ /^ST/ && $ip eq $s_ip)) && exists $SEGMENT_IP_HASH{$ip}){
            next;
        }
        my ($task_thread) = threads->new(\&installThread,$ip,$hostname);
        push @thread_array,$task_thread;
    }
    my $have_problem = 0;
    for my $thread(@thread_array){
        $thread->join;
    }
    system(qq{sudo rm -f /tmp/greenplum-db.install.tmp.tar});
}
sub createSegmentFile{
    logMessage("INFO","Create segment files".("." x 16));
    my ($all_hosts,$all_segs_install) = ($WORK_PATH."/all_hosts",$WORK_PATH."/all_segs_install");
    readpipe(qq{sudo rm -f $all_hosts $all_segs_install});
    my ($all_hosts_handle,$all_segs_install_handle);
    if(!open($all_hosts_handle,">",$all_hosts)){
        errorMessage("Can't open file: $all_hosts");
    }
    if(!open($all_segs_install_handle,">",$all_segs_install)){
        errorMessage("Can't open file: $all_segs_install");
    }
    for my $config(@ALLHOST_CONFIG_ARRAY){
        my ($ip,$hostname,$role,$cur_ring,$cur_order) = @$config;
        print $all_hosts_handle $hostname."\n";
        print $all_hosts_handle $ip."\n";
        if($role =~ /^SE/){
            print $all_segs_install_handle $hostname."\n";
        }
    }
    close $all_hosts_handle;
    close $all_segs_install_handle;
}
sub exchangeGpadminKey{
    logMessage("INFO","Exchange key for $GP_ADMIN_NAME");
    my $command = qq{sudo su - $GP_ADMIN_NAME -c ". /usr/local/greenplum-db/greenplum_path.sh > /dev/null 2>&1;gpssh-exkeys -f $WORK_PATH/all_hosts"};
    executeWithExpect($command,0,([["password",decode($GP_ADMIN_PASSWD),1],["*#"]]));
}
sub initGpSystem{
    if($IGNORE_INIT){
        logMessage("INFO","Ignore greenplum initsystem");
        return;
    }
    logMessage("INFO","Start greenplum initsystem");
    readpipe(qq{. /usr/local/greenplum-db/greenplum_path.sh > /dev/null 2>&1;psql -h 127.0.0.1 -U $GP_ADMIN_NAME -p $MASTER_PORT -l > /dev/null 2>&1});
    my $exit_code = $? >> 8;
    if($exit_code == 0){
        logMessage("WARN","Find cluster run on the same port, skip gpinitsystem.");
        $CLUSTER_EXISTS = 1;
        return;
    }
    my @init_config = ();
    push @init_config,qq{ARRAY_NAME="Pivotal Greenplum DW"};
    push @init_config,qq{SEG_PREFIX=$PREFIX};
    push @init_config,qq{PORT_BASE=$PORT_BASE};
    my $data_directory = "declare -a DATA_DIRECTORY=(";
    for my $path(@SEGMENT_DEV){
        for my $idx(1 .. $SEGS_PER_DISK){
            $data_directory = $data_directory."$path/primary/default ";
        }
    }
    my ($m_ip,$m_hostname) = @MASTER_CONFIG;
    $data_directory = trim($data_directory).")";
    push @init_config,$data_directory;
    push @init_config,qq{MASTER_HOSTNAME=$m_hostname};
    push @init_config,qq{MASTER_DIRECTORY=$MASTER_DEV/master/default};
    push @init_config,qq{MASTER_PORT=$MASTER_PORT};
    push @init_config,qq{TRUSTED_SHELL=ssh};
    push @init_config,qq{CHECK_POINT_SEGMENTS=8};
    push @init_config,qq{ENCODING=UNICODE};
    system(qq{sudo mkdir -p $WORK_PATH/gpdbinstall;sudo touch $WORK_PATH/gpdbinstall/gpinitsystem_config;sudo chmod -R 777 $WORK_PATH/gpdbinstall});
    open(my $init_handle,">","$WORK_PATH/gpdbinstall/gpinitsystem_config");
    for my $line(@init_config){
        print $init_handle $line."\n";
    }
    close $init_handle;
    system(qq{sudo su - $GP_ADMIN_NAME -c "rm -f gpAdminLogs/gpinitsystem_*.log"});
    my $command = qq{sudo su - $GP_ADMIN_NAME -c "gpinitsystem -a --lc-collate=C -c $WORK_PATH/gpdbinstall/gpinitsystem_config -h $WORK_PATH/all_segs_install"};
    logMessage("INFO","Execute command:\n".$command);
    system($command);
    my $exit_code = $? >> 8;
    if($exit_code != 0){
        errorMessage("Error($exit_code) occur when execute system initialization.");
    }
}
sub addMirror{
    if($IGNORE_INIT){
        logMessage("INFO","Ignore add mirror instance");
        return;
    }
    logMessage("INFO","Add mirror instance".("." x 16));
    if($MIRROR_SPLIT < 1){
        logMessage("WARN","Mirror split value small than 1, no need to add mirrors, skip this step.");
        return;
    }
    if($SEGS_PER_DISK % $MIRROR_SPLIT != 0){
        logMessage("WARN","Can not split mirrors, instance per disk must be integral multiple to host number of mirror split");
        return;
    }
    my $install_seg_size = @SEG_INSTALL_CONFIG_ARRAY;
    if($install_seg_size % ($MIRROR_SPLIT + 1) != 0){
        logMessage("WARN","Can not ensure all mirror loop match the split number for all segments number mod loop number ".($MIRROR_SPLIT + 1)." != 0");
    }
    my @primary_config_list;
    my $query = qq{select hostname,content,fselocation,port from gp_segment_configuration c, pg_filespace_entry e\n};
    $query = $query.qq{where c.dbid = e.fsedbid\n};
    $query = $query.qq{and e.fsefsoid = (select oid from pg_filespace where fsname = 'pg_system')\n};
    $query = $query.qq{and c.preferred_role = 'p' and c.content > -1 order by 1,2};
    @primary_config_list = queryResult($query);
    my %primary_config_map = ();
    for my $config(@primary_config_list){
        my ($hostname,$content,$location,$port) = @$config;
        my $path_legal = 0;
        for my $path(@SEGMENT_DEV){
            if($location =~ /^$path/){
                $location = $path;
                $path_legal = 1;
            }
        }
        if(!$path_legal){
            errorMessage("Primary path is not a known path: $location");
        }
        my @config_array = ();
        if(! exists $primary_config_map{$hostname}){
            $primary_config_map{$hostname} = \@config_array;
        }
        @config_array = @{$primary_config_map{$hostname}};
        push @config_array,[($hostname,$content,$location,$port)];
        $primary_config_map{$hostname} = \@config_array;
    }
    my @mirror_config_list;
    my @node_array;
    my $index = 0;
    my $max_index = @SEG_INSTALL_CONFIG_ARRAY - 1;
    my ($pre_hostname,$pre_number);
    for my $config(@SEG_INSTALL_CONFIG_ARRAY){
        my ($ip,$hostname,$role,$cur_ring,$cur_order) = @$config;
        if($index > 0){
            if($index == $max_index){
                push @node_array,$hostname;
            }
            if($pre_number != $cur_ring || $index == $max_index){
                my $node_size = @node_array;
                my $node_index = 0;
                for my $node(@node_array){
                    my @primary_config_array = @{$primary_config_map{$node}};
                    my $primary_index = 0;
                    for my $primary_config(@primary_config_array){
                        my ($p_hostname,$p_content,$p_location,$p_port) = @$primary_config;
                        my $mirror_position = ((($primary_index / ($SEGS_PER_DISK / $MIRROR_SPLIT)) % $MIRROR_SPLIT) + $node_index + 1) % $node_size;
                        my $m_hostname = $node_array[$mirror_position];
                        my ($m_port,$m_r_port,$p_r_port) = ($p_port + 10000,$p_port + 11000,$p_port + 1000);
                        my $m_config = "mirror$p_content=$p_content:$m_hostname:$m_port:$m_r_port:$p_r_port:$p_location/mirror/default/$PREFIX"."$p_content";
                        push @mirror_config_list,$m_config;
                        $primary_index += 1;
                    }
                    $node_index += 1;
                }
                @node_array = ();
            }
        }
        push @node_array,$hostname;
        ($pre_hostname,$pre_number) = ($pre_hostname,$cur_ring);
        $index += 1;
    }
    my $file_name = "$WORK_PATH/gp_add_mirror_config";
    my $file_handle;
    if(!open($file_handle,">",$file_name)){
        errorMessage("Can't open file: $file_name");
    }
    print $file_handle "filespaceOrder=\n";
    for my $config(@mirror_config_list){
        print $file_handle $config."\n";
    }
    close $file_handle;
    my $command = qq{sudo su - $GP_ADMIN_NAME -c "gpaddmirrors -i $file_name -a"};
    if($CLUSTER_EXISTS){
        logMessage("INFO","Addmirrors use this command".$command);
    }else{
        logMessage("INFO","Execute command:\n".$command);
        system($command);
        my $exit_code = $? >> 8;
        if($exit_code != 0){
            errorMessage("Error($exit_code) occur when execute gpaddmirrors.");
        }
        for my $trys(1 .. 200){
            sleep(3);
            my $command = qq{. /usr/local/greenplum-db/greenplum_path.sh > /dev/null 2>&1;psql -h 127.0.0.1 -U $GP_ADMIN_NAME -p $MASTER_PORT -d template1 -qtAXc};
            $command = $command.qq{ "select count(*) from gp_segment_configuration where mode <> 's';"};
            my $output = trim(readpipe($command));
            if($output eq "0"){
                last;
            }
            logMessage("INFO","Waiting for mirror mode change to Synchronized [$output]");
        }
    }
}
sub addGPFileSpace{
    if($IGNORE_INIT){
        logMessage("INFO","Ignore add filespace");
        return;
    }
    logMessage("INFO","Add one filespace gpfs".("." x 16));
    my $query = qq{select hostname,dbid,replace(fselocation,'default','gpfs') path from gp_segment_configuration c, pg_filespace_entry e
    where c.dbid = e.fsedbid
    and e.fsefsoid = (select oid from pg_filespace where fsname = 'pg_system')
    order by 2;};
    my @gpfs_config_list = queryResult($query);
    my $file_name = "$WORK_PATH/gpfilespace_gpfs";
    my $file_handle;
    if(!open($file_handle,">",$file_name)){
        errorMessage("Can't open file: $file_name");
    }
    print $file_handle "filespace:gpfs\n";
    for my $config(@gpfs_config_list){
        my ($hostname,$dbid,$path) = @$config;
        print $file_handle "$hostname:$dbid:$path"."\n";
    }
    close $file_handle;
    my $command = qq{sudo su - $GP_ADMIN_NAME -c "gpfilespace -c $file_name"};
    if($CLUSTER_EXISTS){
        logMessage("INFO","Greenplum database is running pre this installation, you can use this command to add gp filespace:\n ".$command);
    }else{
        logMessage("INFO","Execute command:\n".$command);
        system($command);
        my $exit_code = $? >> 8;
        if($exit_code != 0){
            errorMessage("Error($exit_code) occur when execute gpfilespace.");
        }
    }
}
sub addStandby{
    if($IGNORE_INIT){
        logMessage("INFO","Ignore add standby master");
        return;
    }
    logMessage("INFO","Add standby master".("." x 16));
    if(@STANDBY_CONFIG > 0){
        my ($ip,$hostname) = @STANDBY_CONFIG;
        my $command = qq{sudo su - $GP_ADMIN_NAME -c "gpinitstandby -a -s $hostname"};
        if($CLUSTER_EXISTS){
            logMessage("INFO","Use this command to add standby master:\n".$command);
        }else{
            executeWithExpect($command,0,([[">","",1],["*#"]]));
        }
    }else{
        logMessage("WARN","No standby master should config.");
    }
}
sub gpConfig{
    if($IGNORE_INIT){
        logMessage("INFO","Ignore config greenplum parameters");
        return;
    }
    my %gp_config_hash = ();
    for my $config(@GP_CONFIG){
        my ($name,$value) = split(/=/,$config,2);
        ($name,$value) = (lc(trim($name)),trim($value));
        if(! exists $gp_config_hash{$name}){
            $gp_config_hash{$name} = $value;
        }
    }
    if(! exists $gp_config_hash{"gp_vmem_protect_limit"}){
        my ($mas_value,$seg_value);
        my $pri_count = @SEGMENT_DEV * $SEGS_PER_DISK;
        my $master_mem = trim(readpipe(q#free -g|grep Mem|awk '{print $2}'#));
        my $gpssh_command = qq{sudo su - $GP_ADMIN_NAME <<END_OF_COMMAND}.q#|grep Mem|awk '{print $3}'|sort -n|uniq#;
        $gpssh_command = $gpssh_command.qq{\n. /usr/local/greenplum-db/greenplum_path.sh > /dev/null 2>&1\n};
        $gpssh_command = $gpssh_command.q#gpssh -f #.qq#$WORK_PATH"/all_segs_install"#.q# -e 'free -g'#.qq{\nEND_OF_COMMAND};
        my @segment_mem = readpipe($gpssh_command);
        if(@segment_mem > 1){
            logMessage("WARN","All segment hosts's memery not consistent, will use the smallest to config gp_vmem_protect_limit");
        }
        $seg_value = $segment_mem[0];
        my ($m_ip,$m_hostname) = @MASTER_CONFIG;
        if(exists $SEGMENT_IP_HASH{$m_ip}){
            $mas_value = int($seg_value / ($pri_count + 2) * 2);
            $seg_value = int($mas_value / 2);
        }else{
            $mas_value = int($master_mem / 2);
            $seg_value = int($seg_value * 0.9 / $pri_count);
        }
        $mas_value = $mas_value < 8 ? 8192 : $mas_value * 1024;
        $seg_value = $seg_value < 8 ? 8192 : $seg_value * 1024;
        if($mas_value > 8192 && $seg_value > 8192){
            $gp_config_hash{"gp_vmem_protect_limit"} = "-v $seg_value -m $mas_value";
        }
    }
    for my $key(keys %DEFAULT_GPCONFIG){
        if(! exists $gp_config_hash{$key}){
            $gp_config_hash{$key} = $DEFAULT_GPCONFIG{$key};
        }
    }
    for my $key(keys %gp_config_hash){
        my $gpconfig = qq{sudo su - $GP_ADMIN_NAME <<END_OF_COMMAND\n. /usr/local/greenplum-db/greenplum_path.sh > /dev/null 2>&1\n};
        $gpconfig = $gpconfig.qq{gpconfig -c $key }.$gp_config_hash{$key}.qq{\nEND_OF_COMMAND};
        system($gpconfig);
    }
}
sub createExpandFile{
    if($EXPAND eq ""){
        return;
    }
    my $primary_dbid_index = $MAX_DBID + 1;
    my $mirror_dbid_index = $MAX_DBID + @SEG_INSTALL_CONFIG_ARRAY * @SEGMENT_DEV * $SEGS_PER_DISK + 1;
    my $content_index = $MAX_CONTENT + 1;
    my (@node_array,@primary_config,@mirror_config,@primary_filespace,@mirror_filespace);
    my $index = 0;
    my $max_index = @SEG_INSTALL_CONFIG_ARRAY - 1;
    my ($pre_hostname,$pre_number);
    for my $config(@SEG_INSTALL_CONFIG_ARRAY){
        my ($ip,$hostname,$role,$cur_ring,$cur_order) = @$config;
        if($index > 0 || $index == $max_index){
            if($index == $max_index){
                push @node_array,$hostname;
            }
            if($pre_number != $cur_ring || $index == $max_index){
                my $node_size = @node_array;
                my $node_index = 0;
                for my $primary_host(@node_array){
                    my $port_index = $PORT_BASE;
                    my $primary_index = 0;
                    for my $path(@SEGMENT_DEV){
                        for my $in_disk_index(1 .. $SEGS_PER_DISK){
                            my ($primary_port,$primary_rep_port,$mirror_port,$mirror_rep_port) = ($port_index,$port_index + 1000,$port_index + 10000,$port_index + 11000);
                            push @primary_config,"$primary_host:$primary_host:$primary_port:$path/primary/default/$PREFIX"."$content_index:$primary_dbid_index:$content_index:p:$primary_rep_port";
                            push @primary_filespace,$primary_dbid_index.":/$path/primary/gpfs/$PREFIX"."$content_index";
                            if($EXISTS_MIRROR){
                                my $mirror_position = ((($primary_index / ($SEGS_PER_DISK / $MIRROR_SPLIT)) % $MIRROR_SPLIT) + $node_index + 1) % $node_size;
                                my $mirror_host = $node_array[$mirror_position];
                                push @mirror_config,"$mirror_host:$mirror_host:$mirror_port:$path/mirror/default/$PREFIX"."$content_index:$mirror_dbid_index:$content_index:m:$mirror_rep_port";
                                push @mirror_filespace,$mirror_dbid_index.":/$path/mirror/gpfs/$PREFIX"."$content_index";
                            }
                            $primary_index += 1;
                            $primary_dbid_index += 1;
                            $mirror_dbid_index += 1;
                            $content_index += 1;
                        }
                    }
                    $node_index += 1;
                }
                @node_array = ();
            }
        }
        push @node_array,$hostname;
        ($pre_hostname,$pre_number) = ($pre_hostname,$cur_ring);
        $index += 1;
    }
    my $input_file = "/tmp/gpexpand_inputfile_".strftime("%Y%m%d_%H%M%S",localtime);
    my $FILE_HANDLE;
    if(!open($FILE_HANDLE,">",$input_file)){
        errorMessage("Can't open file: $input_file");
    }
    print $FILE_HANDLE join("\n",@primary_config)."\n";
    if($EXISTS_MIRROR){
        print $FILE_HANDLE join("\n",@mirror_config)."\n";
    }
    close $FILE_HANDLE;
    my $input_file_fs = $input_file.".fs";
    if(!open($FILE_HANDLE,">",$input_file_fs)){
        errorMessage("Can't open file: $input_file_fs");
    }
    print $FILE_HANDLE "filespaceOrder=gpfs\n";
    print $FILE_HANDLE join("\n",@primary_filespace)."\n";
    if($EXISTS_MIRROR){
        print $FILE_HANDLE join("\n",@mirror_filespace)."\n";
    }
    close $FILE_HANDLE;
    logMessage("INFO","Input config file for gpexpand is: $input_file and $input_file_fs");
}
sub main{
    getOption();
    checkEnvironment();
    checkOption();
    logMessage("INFO","Start greenplum cluster auto install process".("." x 15));
    logMessage("INFO","Run command: ".$_[0]);
    getExistsInformation();
    checkHostsConfig();
    checkPasswordAndSudo();
    checkRingConfig();
    modifySystemConfig();
    installBinary();
    createSegmentFile();
    exchangeGpadminKey();
    initGpSystem();
    addMirror();
    addGPFileSpace();
    addStandby();
    gpConfig();
    createExpandFile();
}
my $command_string = $0." ".join(" ",@ARGV);
$| = 1;
main($command_string);
=start
____CONFIG_COMMAND_SHELL_START____
#!/bin/bash
cd $(cd "$(dirname "$0")"; pwd)
HSNM=$1
USNM=$2
PSWD=$3
USID=$4
MODE=$5
MSPT=$6
DEVC=$7
Directorys=""
##################################################################################
CURRENT_USER=`whoami`
if [ $CURRENT_USER != "root" ];then
    echo "This script can only be executed by the root."
    exit 1
fi
##################################################################################
IS_RHEL=0
IS_SuSE=0
RHEL_VERSION=0
if [ -f /etc/redhat-release ];then
    IS_RHEL=1
    RHEL_VERSION=`cat /etc/redhat-release|grep -o "[0-9]"|head -n 1`
elif [ -f /etc/SuSE-release ];then
    IS_SuSE=1
elif [ -f /etc/cgsl-release ];then
    IS_RHEL=1
    RHEL_VERSION=7
fi
if [[ $IS_RHEL == 0 && $IS_SuSE == 0 ]];then
    echo "Unsupported operating systems."
    exit 3
fi
##################################################################################
missinginfo=""
for command in "sed" "zip" "unzip" "less" "bash" "tar" "perl" "ssh" "ifconfig" "mkfs.xfs";do
    which $command                                                                > /dev/null 2>&1
    exitcode=$?
    if [ $exitcode != 0 ];then
        if [ "$missinginfo" == "" ];then
            missinginfo=$command
        else
            missinginfo=$missinginfo","$command
        fi
    fi
done
CG_CONFIG=""
if [ $IS_RHEL == 1 ];then
    if [ $RHEL_VERSION == 7 ];then
        CG_CONFIG=`systemctl status cgconfig.service 2> /dev/null`
    else
        CG_CONFIG=`service cgconfig status 2> /dev/null`
    fi
elif [ $IS_SuSE == 1 ];then
    CG_CONFIG=`systemctl enable cgconfig.service 2> /dev/null`
fi
if [ "$CG_CONFIG" == "" ];then
    missinginfo=$missinginfo",[cgroup_not_ready]"
fi
if [ "$missinginfo" != "" ];then
    echo "Environment not enough to continue install, missing: $missinginfo"
    exit 2
fi
##################################################################################
if [ $IS_RHEL == 1 ];then
    if [ $RHEL_VERSION == 7 ];then
        systemctl stop firewalld.service                                          > /dev/null 2>&1
        systemctl disable firewalld.service                                       > /dev/null 2>&1
    else
        service iptables stop                                                     > /dev/null 2>&1
        chkconfig iptables off                                                    > /dev/null 2>&1
    fi
elif [ $IS_SuSE == 1 ];then
    yast runlevel delete service=SuSEfirewall2_init runlevels=B                   > /dev/null 2>&1
    yast runlevel delete service=SuSEfirewall2_setup runlevels=B                  > /dev/null 2>&1
fi
##################################################################################
if [ $IS_RHEL == 1 ];then
    sed s/^SELINUX=.*$/SELINUX=disabled/ -i /etc/selinux/config
    setenforce 0                                                                  > /dev/null 2>&1
elif [ $IS_SuSE == 1 ];then
    yast runlevel delete service=boot.apparmor runlevels=B                        > /dev/null 2>&1
fi
##################################################################################
hostname $HSNM
if [ -f /etc/sysconfig/network ];then
    sed -e /NETWORKING/d -e /HOSTNAME/d -i /etc/sysconfig/network
    echo "NETWORKING=yes"  >> /etc/sysconfig/network
    echo "HOSTNAME=$HSNM"  >> /etc/sysconfig/network
fi
if [ -f /etc/hostname ];then
    echo $HSNM > /etc/hostname
fi
if [ -f /etc/HOSTNAME ];then
    echo $HSNM > /etc/HOSTNAME
fi
##################################################################################
sed -e s/^ulimit/#ulimit/ -i /etc/profile                                         > /dev/null 2>&1
sed -e /^[^#]/d -e /^[[:space:]]*$/d -i /etc/security/limits.conf
echo ''                              >> /etc/security/limits.conf
echo '* soft nofile 1048576'         >> /etc/security/limits.conf
echo '* hard nofile 1048576'         >> /etc/security/limits.conf
echo '* soft nproc  1048576'         >> /etc/security/limits.conf
echo '* hard nproc  1048576'         >> /etc/security/limits.conf
nprocname="/etc/security/limits.d/90-nproc.conf"
if [ -f "/etc/security/limits.d/20-nproc.conf" ];then
    nprocname="/etc/security/limits.d/20-nproc.conf"
fi
if [ -f $nprocname ];then
    sed -e /^[^#]/d -e /^[[:space:]]*$/d -i          $nprocname
    echo ''                                       >> $nprocname
    echo '*          soft    nproc     unlimited' >> $nprocname
    echo 'root       soft    nproc     unlimited' >> $nprocname
fi
##################################################################################
echo -n 'kernel.shmmax = 50000000000
kernel.shmmni = 40960
kernel.shmall = 40000000000
kernel.sem = 250 5120000 100 20480
kernel.sysrq = 1
kernel.core_uses_pid = 1
kernel.msgmnb = 1048576
kernel.msgmax = 1048576
kernel.msgmni = 32768
net.ipv4.tcp_syncookies = 1
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_max_syn_backlog = 32768
net.ipv4.conf.all.arp_filter = 1
net.ipv4.ip_local_port_range = 1025 65535
net.ipv4.ip_local_reserved_ports = 5432,40000-40127,41000-41127,50000-50127,51000-51127
net.core.netdev_max_backlog = 80000
net.core.rmem_default = 2097152
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
vm.overcommit_memory = 2
vm.overcommit_ratio = 95
vm.swappiness = 10
vm.dirty_expire_centisecs = 500
vm.dirty_writeback_centisecs = 100
vm.dirty_background_ratio = 0
vm.dirty_ratio=0
vm.dirty_background_bytes = 1610612736
vm.dirty_bytes = 4294967296
'|awk -F ' = ' '{system("sed -e /"$1"/d -i /etc/sysctl.conf;echo "$1" = "$2" >> /etc/sysctl.conf")}'
sysctl -p                                                                         > /dev/null 2>&1
##################################################################################
localfile="/etc/rc.d/rc.local"
if [ -f "/etc/init.d/boot.local" ];then
    localfile="/etc/init.d/boot.local"
fi
chmod +x $localfile
sed -e /^[^#]/d -e /^[[:space:]]*$/d -i $localfile
echo ''                                                                   >> $localfile
echo 'touch /var/lock/subsys/local'                                       >> $localfile
echo 'blockdev --setra 16384 /dev/sd*'                                    >> $localfile
echo 'for i in /sys/block/sd*/queue/scheduler;do echo deadline > $i;done' >> $localfile
echo 'echo never > /sys/kernel/mm/transparent_hugepage/enabled'           >> $localfile
sh $localfile                                                                     > /dev/null 2>&1
##################################################################################
sed s/.*MaxStartups.*/'MaxStartups 400:30:500'/ -i /etc/ssh/sshd_config
if [ $IS_RHEL == 1 ];then
    if [ $RHEL_VERSION == 7 ];then
        systemctl reload sshd.service                                             > /dev/null 2>&1
    else
        service sshd reload                                                       > /dev/null 2>&1
    fi
elif [ $IS_SuSE == 1 ];then
    service ssh reload                                                            > /dev/null 2>&1
fi
##################################################################################
groupadd -r -g $USID $USNM                                                        > /dev/null 2>&1
useradd -r -m -g $USNM -u $USID $USNM                                             > /dev/null 2>&1
exitcode=$?
echo $PSWD|base64 -d|passwd --stdin $USNM                                         > /dev/null 2>&1
id $USNM                                                                          > /dev/null 2>&1
exitcode=$?
if [ $exitcode != 0 ];then
    echo "No such user:$USNM"
    exit 4
fi
##################################################################################
devices=${DEVC//./ }
array=($devices)
nametail=1
for device in ${array[@]};do
    if [ -d $device ];then
        Directorys="$Directorys $device"
    elif [ -e $device ];then
        hasconfig=`cat /etc/fstab|grep -w "^$device"|wc -l`
        if [ $hasconfig == 0 ];then
            mkfs.xfs -f $device                                                   > /dev/null 2>&1
            mkdir -p /data$nametail                                               > /dev/null 2>&1
            echo "$device /data$nametail xfs nodev,noatime,nobarrier,inode64 0 0" >> /etc/fstab
            Directorys="$Directorys /data$nametail"
        else
            Directorys="$Directorys `cat /etc/fstab|grep -w "^$device"|head -n 1|awk '{print $2}'`"
        fi
    else
        echo "Device or path not exists: $device."
        exit 5
    fi
    nametail=$((nametail + 1))
done
mount -a                                                                          > /dev/null 2>&1
##################################################################################
array=($Directorys)
for path in ${array[@]};do
    if [ "$MODE" == "M" ];then
        mkdir -p $path/master/{default,gpfs}                                      > /dev/null 2>&1
        chown -R $USNM. $path/master                                              > /dev/null 2>&1
    elif [ "$MODE" == "S" ];then
        mkdir -p $path/{primary,mirror}/{default,gpfs}                            > /dev/null 2>&1
        chown -R $USNM. $path/{primary,mirror}                                    > /dev/null 2>&1
    fi
done
##################################################################################
if [ "$MODE" == "M" ];then
    array=($Directorys)
    masterpath=${array[0]}
    sed -e /greenplum_path.sh/d -e /MASTER_DATA_DIRECTORY/d -e /PGPORT/d   -i /home/$USNM/.bashrc
    echo '. /usr/local/greenplum-db/greenplum_path.sh'                     >> /home/$USNM/.bashrc
    echo "export MASTER_DATA_DIRECTORY=$masterpath/master/default/GPSEG-1" >> /home/$USNM/.bashrc
    echo "export PGPORT=$MSPT"                                             >> /home/$USNM/.bashrc
fi
##################################################################################
mkdir -p /etc/cgconfig.d                                                          > /dev/null 2>&1
touch /etc/cgconfig.d/gpdb.conf                                                   > /dev/null 2>&1
echo "group gpdb {
     perm {
         task {
             uid = $USNM;
             gid = $USNM;
         }
         admin {
             uid = $USNM;
             gid = $USNM;
         }
     }
     cpu {
     }
     cpuacct {
     }
     memory {
     }
     cpuset {
     }
 }" > /etc/cgconfig.d/gpdb.conf
if [ $IS_RHEL == 1 ];then
    if [ $RHEL_VERSION == 7 ];then
        cgconfigparser -l /etc/cgconfig.d/gpdb.conf                               > /dev/null 2>&1
        systemctl enable cgconfig.service                                         > /dev/null 2>&1
    else
        service cgconfig start                                                    > /dev/null 2>&1
        chkconfig cgconfig on                                                     > /dev/null 2>&1
    fi
elif [ $IS_SuSE == 1 ];then
    cgconfigparser -l /etc/cgconfig.d/gpdb.conf                                   > /dev/null 2>&1
    systemctl enable cgconfig.service                                             > /dev/null 2>&1
fi
##################################################################################
echo "####----"$Directorys
##################################################################################
____CONFIG_COMMAND_SHELL_END____
=cut
